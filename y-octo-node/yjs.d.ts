// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   lib0/observable
//   lib0/decoding
//   lib0/encoding

import { ObservableV2 } from "lib0/observable";
import * as decoding from "lib0/decoding";
import * as encoding from "lib0/encoding";

declare module Y {
  /**
   * A Yjs instance handles the state of shared data.
   */
  export class Doc extends ObservableV2<DocEvents> {
    constructor(opts?: DocOpts);
    gc: boolean;
    gcFilter: (arg0: Struct.Item) => boolean;
    clientID: number;
    guid: string;
    collectionid: string | null;
    share: Map<string, Type.AbstractType<Type.Event.YEvent<any>>>;
    store: Struct.StructStore;
    subdocs: Set<Doc>;
    shouldLoad: boolean;
    autoLoad: boolean;
    meta: any;
    /**
     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
     */
    isLoaded: boolean;
    /**
     * This is set to true when the connection provider has successfully synced with a backend.
     * Note that when using peer-to-peer providers this event may not provide very useful.
     * Also note that not all providers implement this feature. Provider authors are encouraged to fire
     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
     * lost (with false as a parameter).
     */
    isSynced: boolean;
    /**
     * Promise that resolves once the document has been loaded from a presistence provider.
     */
    whenLoaded: Promise<any>;
    whenSynced: Promise<any>;
    /**
     * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
     *
     * `load()` might be used in the future to request any provider to load the most current data.
     *
     * It is safe to call `load()` multiple times.
     */
    load(): void;
    getSubdocs(): Set<Doc>;
    getSubdocGuids(): Set<string>;
    /**
     * Changes that happen inside of a transaction are bundled. This means that
     * the observer fires _after_ the transaction is finished and that all changes
     * that happened inside of the transaction are sent as one message to the
     * other peers.
     *
     * @param {function(Transaction):T} f The function that should be executed as a transaction
     * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
     *
     * @public
     */
    transact<T>(f: (arg0: Transaction) => T, origin?: any): T;
    /**
     * Define a shared data type.
     *
     * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
     * and do not overwrite each other. I.e.
     * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
     *
     * After this method is called, the type is also available on `ydoc.share.get(name)`.
     *
     * *Best Practices:*
     * Define all types right after the Y.Doc instance is created and store them in a separate object.
     * Also use the typed methods `getText(name)`, `getArray(name)`, ..
     *
     * @example
     *   const ydoc = new Y.Doc(..)
     *   const appState = {
     *     document: ydoc.getText('document')
     *     comments: ydoc.getArray('comments')
     *   }
     *
     * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
     * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
     */
    get<Type extends { new (): Type.AbstractType<any> }>(
      name: string,
      TypeConstructor?: Type,
    ): InstanceType<Type>;
    getArray<T>(name?: string | undefined): Type.YArray<T>;
    getText(name?: string | undefined): Type.YText;
    getMap<T>(name?: string | undefined): Type.YMap<T>;
    getXmlElement(name?: string | undefined): Type.YXml.YXmlElement;
    getXmlFragment(name?: string | undefined): Type.YXml.YXmlFragment;
    /**
     * Converts the entire document into a js object, recursively traversing each yjs type
     * Doesn't log types that have not been defined (using ydoc.getType(..)).
     *
     * @deprecated Do not use this method and rather call toJSON directly on the shared types.
     */
    toJSON(): {
      [x: string]: any;
    };
  }
  type DocOpts = {
    /**
     * Disable garbage collection (default: gc=true)
     */
    gc?: boolean | undefined;
    /**
     * Will be called before an Item is garbage collected. Return false to keep the Item.
     */
    gcFilter?: ((arg0: Struct.Item) => boolean) | undefined;
    /**
     * Define a globally unique identifier for this document
     */
    guid?: string | undefined;
    /**
     * Associate this document with a collection. This only plays a role if your provider has a concept of collection.
     */
    collectionid?: string | null | undefined;
    /**
     * Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.
     */
    meta?: any;
    /**
     * If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.
     */
    autoLoad?: boolean | undefined;
    /**
     * Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()
     */
    shouldLoad?: boolean | undefined;
  };
  type DocEvents = {
    destroy: (arg0: Doc) => void;
    load: (arg0: Doc) => void;
    sync: (arg0: boolean, arg1: Doc) => void;
    update: (arg0: Uint8Array, arg1: any, arg2: Doc, arg3: Transaction) => void;
    updateV2: (
      arg0: Uint8Array,
      arg1: any,
      arg2: Doc,
      arg3: Transaction,
    ) => void;
    beforeAllTransactions: (arg0: Doc) => void;
    beforeTransaction: (arg0: Transaction, arg1: Doc) => void;
    beforeObserverCalls: (arg0: Transaction, arg1: Doc) => void;
    afterTransaction: (arg0: Transaction, arg1: Doc) => void;
    afterTransactionCleanup: (arg0: Transaction, arg1: Doc) => void;
    afterAllTransactions: (arg0: Doc, arg1: Array<Transaction>) => void;
    subdocs: (
      arg0: {
        loaded: Set<Doc>;
        added: Set<Doc>;
        removed: Set<Doc>;
      },
      arg1: Doc,
      arg2: Transaction,
    ) => void;
  };

  /**
   * A transaction is created for every change on the Yjs model. It is possible
   * to bundle changes on the Yjs model in a single transaction to
   * minimize the number on messages sent and the number of observer calls.
   * If possible the user of this library should bundle as many changes as
   * possible. Here is an example to illustrate the advantages of bundling:
   *
   * @example
   * const ydoc = new Y.Doc()
   * const map = ydoc.getMap('map')
   * // Log content when change is triggered
   * map.observe(() => {
   *   console.log('change triggered')
   * })
   * // Each change on the map type triggers a log message:
   * map.set('a', 0) // => "change triggered"
   * map.set('b', 0) // => "change triggered"
   * // When put in a transaction, it will trigger the log after the transaction:
   * ydoc.transact(() => {
   *   map.set('a', 1)
   *   map.set('b', 1)
   * }) // => "change triggered"
   */
  export class Transaction {
    constructor(doc: Doc, origin: any, local: boolean);
    /**
     * The Yjs instance.
     */
    doc: Doc;
    /**
     * Describes the set of deleted items by ids
     */
    deleteSet: Struct.DeleteSet;
    /**
     * Holds the state before the transaction started.
     */
    beforeState: Map<number, number>;
    /**
     * Holds the state after the transaction.
     */
    afterState: Map<number, number>;
    /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item.parentSub = null` for YArray)
     */
    changed: Map<Type.AbstractType<Type.Event.YEvent<any>>, Set<string | null>>;
    /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     */
    changedParentTypes: Map<
      Type.AbstractType<Type.Event.YEvent<any>>,
      Array<Type.Event.YEvent<any>>
    >;
    origin: any;
    /**
     * Stores meta information on the transaction
     */
    meta: Map<any, any>;
    /**
     * Whether this change originates from this doc.
     */
    local: boolean;
    subdocsAdded: Set<Doc>;
    subdocsRemoved: Set<Doc>;
    subdocsLoaded: Set<Doc>;
  }

  export function tryGc(
    ds: Struct.DeleteSet,
    store: Struct.StructStore,
    gcFilter: (arg0: Struct.Item) => boolean,
  ): void;
  export function transact<T>(
    doc: Doc,
    f: (arg0: Transaction) => T,
    origin?: any,
    local?: boolean,
  ): T;

  module Struct {
    class DeleteItem {
      constructor(clock: number, len: number);
      clock: number;
      len: number;
    }
    /**
     * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.
     * - When created in a transaction, it must only be accessed after sorting, and merging
     *   - This DeleteSet is send to other clients
     * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore
     * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.
     */
    class DeleteSet {
      clients: Map<number, Array<DeleteItem>>;
    }
    export function iterateDeletedStructs(
      transaction: Transaction,
      ds: DeleteSet,
      f: (arg0: Struct.GC | Struct.Item) => void,
    ): void;
    export function isDeleted(ds: DeleteSet, id: Struct.ID): boolean;
    export function mergeDeleteSets(dss: Array<DeleteSet>): DeleteSet;
    export function createDeleteSet(): DeleteSet;
    export function createDeleteSetFromStructStore(
      ss: Struct.StructStore,
    ): DeleteSet;
    export function equalDeleteSets(ds1: DeleteSet, ds2: DeleteSet): boolean;

    export class ID {
      /**
       * @param {number} client client id
       * @param {number} clock unique per client id, continuous number
       */
      constructor(client: number, clock: number);
      /**
       * Client id
       */
      client: number;
      /**
       * unique per client id, continuous number
       */
      clock: number;
    }
    export function compareIDs(a: ID | null, b: ID | null): boolean;
    export function createID(client: number, clock: number): ID;
    export function findRootTypeKey(type: Type.AbstractType<any>): string;

    export function isParentOf(
      parent: Type.AbstractType<any>,
      child: Struct.Item | null,
    ): boolean;

    export function logType(type: Type.AbstractType<any>): void;

    export class StructStore {
      clients: Map<number, Array<Struct.GC | Struct.Item>>;
      pendingStructs: {
        missing: Map<number, number>;
        update: Uint8Array;
      } | null;
      pendingDs: null | Uint8Array;
    }
    export function getState(store: StructStore, client: number): number;
    export function findIndexSS(
      structs: Array<Struct.Item | Struct.GC>,
      clock: number,
    ): number;
    export function getItem(arg0: StructStore, arg1: ID): Struct.Item;

    export class AbstractStruct {
      constructor(id: Struct.ID, length: number);
      id: Struct.ID;
      length: number;
      get deleted(): boolean;
      /**
       * Merge this struct with the item to the right.
       * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
       * Also this method does *not* remove right from StructStore!
       * @return {boolean} wether this merged with right
       */
      mergeWith(right: AbstractStruct): boolean;
      write(
        encoder: Codec.UpdateEncoderV1 | Codec.UpdateEncoderV2,
        offset: number,
        encodingRef: number,
      ): void;
      integrate(transaction: Transaction, offset: number): void;
    }

    export class GC extends AbstractStruct {
      delete(): void;
      mergeWith(right: GC): boolean;
      write(
        encoder: Codec.UpdateEncoderV1 | Codec.UpdateEncoderV2,
        offset: number,
      ): void;
      getMissing(
        transaction: Transaction,
        store: Struct.StructStore,
      ): null | number;
    }

    /**
     * Abstract class that represents any content.
     */
    export class Item extends AbstractStruct {
      /**
       * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
       */
      constructor(
        id: Struct.ID,
        left: Item | null,
        origin: Struct.ID | null,
        right: Item | null,
        rightOrigin: Struct.ID | null,
        parent: Type.AbstractType<any> | Struct.ID | null,
        parentSub: string | null,
        content: AbstractContent,
      );
      /**
       * The item that was originally to the left of this item.
       */
      origin: Struct.ID | null;
      /**
       * The item that is currently to the left of this item.
       */
      left: Item | null;
      /**
       * The item that is currently to the right of this item.
       */
      right: Item | null;
      /**
       * The item that was originally to the right of this item.
       */
      rightOrigin: Struct.ID | null;
      parent: Type.AbstractType<any> | Struct.ID | null;
      /**
       * If the parent refers to this item with some kind of key (e.g. YMap, the
       * key is specified here. The key is then used to refer to the list in which
       * to insert this item. If `parentSub = null` type._start is the list in
       * which to insert to. Otherwise it is `parent._map`.
       */
      parentSub: string | null;
      /**
       * If this type's effect is redone this type refers to the type that undid
       * this operation.
       */
      redone: Struct.ID | null;
      content: AbstractContent;
      /**
       * bit1: keep
       * bit2: countable
       * bit3: deleted
       * bit4: mark - mark node as fast-search-marker
       */
      info: number;
      /**
       * This is used to mark the item as an indexed fast-search marker
       */
      set marker(arg: boolean);
      get marker(): boolean;
      set keep(arg: boolean);
      /**
       * If true, do not garbage collect this Item.
       */
      get keep(): boolean;
      get countable(): boolean;
      set deleted(arg: boolean);
      /**
       * Whether this item was deleted or not.
       */
      get deleted(): boolean;
      markDeleted(): void;
      /**
       * Return the creator clientID of the missing op or define missing items and return null.
       */
      getMissing(
        transaction: Transaction,
        store: Struct.StructStore,
      ): null | number;
      /**
       * Returns the next non-deleted item
       */
      get next(): Item | null;
      /**
       * Returns the previous non-deleted item
       */
      get prev(): Item | null;
      /**
       * Computes the last content address of this Item.
       */
      get lastId(): Struct.ID;
      /**
       * Try to merge two items
       */
      mergeWith(right: Item): boolean;
      /**
       * Mark this Item as deleted.
       */
      delete(transaction: Transaction): void;
      gc(store: Struct.StructStore, parentGCd: boolean): void;
      /**
       * Transform the properties of this type to binary and write it to an
       * BinaryEncoder.
       *
       * This is called when this Item is sent to a remote peer.
       */
      write(
        encoder: Codec.UpdateEncoderV1 | Codec.UpdateEncoderV2,
        offset: number,
      ): void;
    }

    export class AbstractContent {
      getLength(): number;
      getContent(): Array<any>;
      /**
       * Should return false if this Item is some kind of meta information
       * (e.g. format information).
       *
       * * Whether this Item should be addressable via `yarray.get(i)`
       * * Whether this Item should be counted when computing yarray.length
       */
      isCountable(): boolean;
      copy(): AbstractContent;
      splice(_offset: number): AbstractContent;
      mergeWith(_right: AbstractContent): boolean;
      integrate(_transaction: Transaction, _item: Item): void;
      delete(_transaction: Transaction): void;
      gc(_store: Struct.StructStore): void;
      write(
        _encoder: Codec.UpdateEncoderV1 | Codec.UpdateEncoderV2,
        _offset: number,
      ): void;
      getRef(): number;
    }

    export class Skip extends AbstractStruct {
      delete(): void;
      mergeWith(right: Skip): boolean;
      write(
        encoder: Codec.UpdateEncoderV1 | Codec.UpdateEncoderV2,
        offset: number,
      ): void;
      getMissing(
        transaction: Transaction,
        store: Struct.StructStore,
      ): null | number;
    }
  }

  module Type {
    module Event {
      /**
       * YEvent describes the changes on a YType.
       */
      export class YEvent<T extends AbstractType<any>> {
        /**
         * @param {T} target The changed type.
         * @param {Transaction} transaction
         */
        constructor(target: T, transaction: Transaction);
        /**
         * The type on which this event was created on.
         */
        target: T;
        /**
         * The current target on which the observe callback is called.
         */
        currentTarget: AbstractType<any>;
        /**
         * The transaction that triggered this event.
         */
        transaction: Transaction;
        /**
         * Computes the path from `y` to the changed type.
         *
         * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
         *
         * The following property holds:
         * @example
         *   let type = y
         *   event.path.forEach(dir => {
         *     type = type.get(dir)
         *   })
         *   type === event.target // => true
         */
        get path(): (string | number)[];
        /**
         * Check if a struct is deleted by this event.
         *
         * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
         */
        deletes(struct: Struct.AbstractStruct): boolean;
        get keys(): Map<
          string,
          {
            action: "add" | "update" | "delete";
            oldValue: any;
            newValue: any;
          }
        >;
        /**
         * This is a computed property. Note that this can only be safely computed during the
         * event call. Computing this property after other changes happened might result in
         * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
         * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
         */
        get delta(): {
          insert?: string | object | any[] | AbstractType<any> | undefined;
          retain?: number | undefined;
          delete?: number | undefined;
          attributes?:
            | {
                [x: string]: any;
              }
            | undefined;
        }[];
        /**
         * Check if a struct is added by this event.
         *
         * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
         */
        adds(struct: Struct.AbstractStruct): boolean;
        /**
         * This is a computed property. Note that this can only be safely computed during the
         * event call. Computing this property after other changes happened might result in
         * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
         * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
         */
        get changes(): {
          added: Set<Struct.Item>;
          deleted: Set<Struct.Item>;
          keys: Map<
            string,
            {
              action: "add" | "update" | "delete";
              oldValue: any;
            }
          >;
          delta: Array<{
            insert?: Array<any> | string;
            delete?: number;
            retain?: number;
          }>;
        };
      }

      /**
       * Event that describes the changes on a YArray
       */
      export class YArrayEvent<T> extends YEvent<YArray<T>> {
        constructor(target: YArray<T>, transaction: Transaction);
      }

      /**
       * Event that describes the changes on a YMap.
       */
      export class YMapEvent<T> extends YEvent<YMap<T>> {
        /**
         * @param {YMap<T>} ymap The YArray that changed.
         * @param {Transaction} transaction
         * @param {Set<any>} subs The keys that changed.
         */
        constructor(ymap: YMap<T>, transaction: Transaction, subs: Set<any>);
        keysChanged: Set<any>;
      }

      /**
       * Event that describes the changes on a YText type.
       */
      export class YTextEvent extends YEvent<YText> {
        /**
         * @param {YText} ytext
         * @param {Transaction} transaction
         * @param {Set<any>} subs The keys that changed
         */
        constructor(ytext: YText, transaction: Transaction, subs: Set<any>);
        /**
         * Set of all changed attributes.
         */
        keysChanged: Set<string>;
        /**
         * Compute the changes in the delta format.
         * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
         */
        get delta(): {
          insert?: string | object | AbstractType<any> | undefined;
          delete?: number | undefined;
          retain?: number | undefined;
          attributes?:
            | {
                [x: string]: any;
              }
            | undefined;
        }[];
      }
    }

    export function getTypeChildren(t: AbstractType<any>): Array<Struct.Item>;

    /**
     * Abstract Yjs Type class
     */
    export class AbstractType<EventType> {
      doc: Doc | null;
      get parent(): AbstractType<any> | null;

      /**
       * Makes a copy of this data type that can be included somewhere else.
       *
       * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
       */
      clone(): AbstractType<EventType>;
      /**
       * Observe all events that are created on this type.
       */
      observe(f: (arg0: EventType, arg1: Transaction) => void): void;
      /**
       * Observe all events that are created by this type and its children.
       */
      observeDeep(
        f: (arg0: Array<Event.YEvent<any>>, arg1: Transaction) => void,
      ): void;
      /**
       * Unregister an observer function.
       */
      unobserve(f: (arg0: EventType, arg1: Transaction) => void): void;
      /**
       * Unregister an observer function.
       */
      unobserveDeep(
        f: (arg0: Array<Event.YEvent<any>>, arg1: Transaction) => void,
      ): void;
      toJSON(): any;
    }

    /**
     * A shared Array implementation.
     */
    export class YArray<T>
      extends AbstractType<Event.YArrayEvent<T>>
      implements Iterable<T>
    {
      /**
       * Construct a new YArray containing the specified items.
       * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
       * @param {Array<T>} items
       * @return {YArray<T>}
       */
      static from<
        T extends
          | string
          | number
          | any[]
          | Uint8Array
          | {
              [x: string]: any;
            }
          | null,
      >(items: T[]): YArray<T>;
      /**
       * Makes a copy of this data type that can be included somewhere else.
       *
       * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
       *
       * @return {YArray<T>}
       */
      clone(): YArray<T>;
      get length(): number;
      /**
       * Inserts new content at an index.
       *
       * Important: This function expects an array of content. Not just a content
       * object. The reason for this "weirdness" is that inserting several elements
       * is very efficient when it is done as a single operation.
       *
       * @example
       *  // Insert character 'a' at position 0
       *  yarray.insert(0, ['a'])
       *  // Insert numbers 1, 2 at position 1
       *  yarray.insert(1, [1, 2])
       *
       * @param {number} index The index to insert content at.
       * @param {Array<T>} content The array of content
       */
      insert(index: number, content: Array<T>): void;
      /**
       * Appends content to this YArray.
       *
       * @param {Array<T>} content Array of content to append.
       *
       * @todo Use the following implementation in all types.
       */
      push(content: Array<T>): void;
      /**
       * Prepends content to this YArray.
       *
       * @param {Array<T>} content Array of content to prepend.
       */
      unshift(content: Array<T>): void;
      /**
       * Deletes elements starting from an index.
       *
       * @param {number} index Index at which to start deleting elements
       * @param {number} length The number of elements to remove. Defaults to 1.
       */
      delete(index: number, length?: number): void;
      /**
       * Returns the i-th element from a YArray.
       *
       * @param {number} index The index of the element to return from the YArray
       * @return {T}
       */
      get(index: number): T;
      /**
       * Transforms this YArray to a JavaScript Array.
       *
       * @return {Array<T>}
       */
      toArray(): Array<T>;
      /**
       * Returns a portion of this YArray into a JavaScript Array selected
       * from start to end (end not included).
       *
       * @param {number} [start]
       * @param {number} [end]
       * @return {Array<T>}
       */
      slice(start?: number | undefined, end?: number | undefined): Array<T>;
      /**
       * Transforms this Shared Type to a JSON object.
       *
       * @return {Array<any>}
       */
      toJSON(): Array<any>;
      /**
       * Returns an Array with the result of calling a provided function on every
       * element of this YArray.
       *
       * @template M
       * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
       * @return {Array<M>} A new array with each element being the result of the
       *                 callback function
       */
      map<M>(f: (arg0: T, arg1: number, arg2: YArray<T>) => M): M[];
      /**
       * Executes a provided function once on every element of this YArray.
       *
       * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
       */
      forEach(f: (arg0: T, arg1: number, arg2: YArray<T>) => void): void;
      /**
       * @return {IterableIterator<T>}
       */
      [Symbol.iterator](): IterableIterator<T>;
    }

    /**
     * A shared Map implementation.
     */
    export class YMap<MapType>
      extends AbstractType<Event.YMapEvent<MapType>>
      implements Iterable<[string, MapType]>
    {
      /**
       *
       * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
       */
      constructor(entries?: Iterable<readonly [string, any]> | undefined);
      /**
       * Makes a copy of this data type that can be included somewhere else.
       *
       * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
       */
      clone(): YMap<MapType>;
      /**
       * Transforms this Shared Type to a JSON object.
       */
      toJSON(): {
        [x: string]: any;
      };
      /**
       * Returns the size of the YMap (count of key/value pairs)
       */
      get size(): number;
      /**
       * Returns the keys for each element in the YMap Type.
       */
      keys(): IterableIterator<string>;
      /**
       * Returns the values for each element in the YMap Type.
       */
      values(): IterableIterator<MapType>;
      /**
       * Returns an Iterator of [key, value] pairs
       */
      entries(): IterableIterator<[string, MapType]>;
      /**
       * Executes a provided function on once on every key-value pair.
       *
       * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
       */
      forEach(
        f: (arg0: MapType, arg1: string, arg2: YMap<MapType>) => void,
      ): void;
      /**
       * Remove a specified element from this YMap.
       *
       * @param {string} key The key of the element to remove.
       */
      delete(key: string): void;
      /**
       * Adds or updates an element with a specified key and value.
       * @template {MapType} VAL
       *
       * @param {string} key The key of the element to add to this YMap
       * @param {VAL} value The value of the element to add
       * @return {VAL}
       */
      set<VAL extends MapType>(key: string, value: VAL): VAL;
      /**
       * Returns a specified element from this YMap.
       *
       * @param {string} key
       * @return {MapType|undefined}
       */
      get(key: string): MapType | undefined;
      /**
       * Returns a boolean indicating whether the specified key exists or not.
       *
       * @param {string} key The key to test.
       * @return {boolean}
       */
      has(key: string): boolean;
      /**
       * Removes all elements from this YMap.
       */
      clear(): void;
      /**
       * Returns an Iterator of [key, value] pairs
       *
       * @return {IterableIterator<[string, MapType]>}
       */
      [Symbol.iterator](): IterableIterator<[string, MapType]>;
    }

    export function cleanupYTextFormatting(type: YText): number;

    /**
     * Type that represents text with formatting information.
     *
     * This type replaces y-richtext as this implementation is able to handle
     * block formats (format information on a paragraph), embeds (complex elements
     * like pictures and videos), and text formats (**bold**, *italic*).
     */
    export class YText extends AbstractType<Event.YTextEvent> {
      /**
       * @param {String} [string] The initial value of the YText.
       */
      constructor(string?: string | undefined);
      /**
       * Number of characters of this text type.
       */
      get length(): number;
      /**
       * Makes a copy of this data type that can be included somewhere else.
       *
       * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
       */
      clone(): YText;
      /**
       * Returns the unformatted string representation of this YText type.
       */
      toJSON(): string;
      /**
       * Apply a {@link Delta} on this shared YText type.
       *
       * @param {any} delta The changes to apply on this element.
       * @param {object}  opts
       * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
       */
      applyDelta(delta: any, opts?: { sanitize?: boolean | undefined }): void;
      /**
       * Returns the Delta representation of this YText type.
       */
      toDelta(
        snapshot?: Snapshot.Snapshot | undefined,
        prevSnapshot?: Snapshot.Snapshot | undefined,
        computeYChange?:
          | ((arg0: "removed" | "added", arg1: Struct.ID) => any)
          | undefined,
      ): any;
      /**
       * Insert text at a given index.
       *
       * @param {number} index The index at which to start inserting.
       * @param {String} text The text to insert at the specified position.
       * @param {TextAttributes} [attributes] Optionally define some formatting
       *                                    information to apply on the inserted
       *                                    Text.
       * @public
       */
      insert(
        index: number,
        text: string,
        attributes?: Object | undefined,
      ): void;
      /**
       * Inserts an embed at a index.
       *
       * @param {number} index The index to insert the embed at.
       * @param {Object | AbstractType<any>} embed The Object that represents the embed.
       * @param {TextAttributes} [attributes] Attribute information to apply on the
       *                                    embed
       */
      insertEmbed(
        index: number,
        embed: Object | AbstractType<any>,
        attributes?: Object | undefined,
      ): void;
      /**
       * Deletes text starting from an index.
       *
       * @param {number} index Index at which to start deleting.
       * @param {number} length The number of characters to remove. Defaults to 1.
       *
       * @public
       */
      delete(index: number, length: number): void;
      /**
       * Assigns properties to a range of text.
       *
       * @param {number} index The position where to start formatting.
       * @param {number} length The amount of characters to assign properties to.
       * @param {TextAttributes} attributes Attribute information to apply on the
       *                                    text.
       */
      format(index: number, length: number, attributes: TextAttributes): void;
      /**
       * Removes an attribute.
       *
       * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
       *
       * @param {String} attributeName The attribute name that is to be removed.
       */
      removeAttribute(attributeName: string): void;
      /**
       * Sets or updates an attribute.
       *
       * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
       *
       * @param {String} attributeName The attribute name that is to be set.
       * @param {any} attributeValue The attribute value that is to be set.
       */
      setAttribute(attributeName: string, attributeValue: any): void;
      /**
       * Returns an attribute value that belongs to the attribute name.
       *
       * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
       *
       * @param {String} attributeName The attribute name that identifies the
       *                               queried value.
       * @return {any} The queried attribute value.
       */
      getAttribute(attributeName: string): any;
      /**
       * Returns all attribute name/value pairs in a JSON Object.
       *
       * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
       *
       * @return {Object<string, any>} A JSON Object that describes the attributes.
       */
      getAttributes(): {
        [x: string]: any;
      };
    }
    /**
     * Attributes that can be assigned to a selection of text.
     */
    export type TextAttributes = Object;

    module YXml {
      /**
       * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
       * position within them.
       *
       * Can be created with {@link YXmlFragment#createTreeWalker}
       */
      export class YXmlTreeWalker
        implements Iterable<YXmlElement | YXmlText | YXmlElement | YXmlHook>
      {
        constructor(
          root: YXmlFragment | YXmlElement,
          f?: ((arg0: AbstractType<any>) => boolean) | undefined,
        );
        /**
         * Get the next node.
         */
        next(): IteratorResult<YXmlElement | YXmlText | YXmlHook>;
        [Symbol.iterator](): YXmlTreeWalker;
      }
      /**
       * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
       * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
       * nodeName and it does not have attributes. Though it can be bound to a DOM
       * element - in this case the attributes and the nodeName are not shared.
       */
      export class YXmlFragment extends AbstractType<YXmlEvent> {
        constructor();
        get firstChild():
          | YXmlElement<{
              [key: string]: string;
            }>
          | YXmlText
          | null;
        /**
         * Makes a copy of this data type that can be included somewhere else.
         *
         * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
         */
        clone(): YXmlFragment;
        get length(): number;
        /**
         * Create a subtree of childNodes.
         *
         * @example
         * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
         * for (let node in walker) {
         *   // `node` is a div node
         *   nop(node)
         * }
         *
         * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
         *                          returns a Boolean indicating whether the child
         *                          is to be included in the subtree.
         * @return {YXmlTreeWalker} A subtree and a position within it.
         */
        createTreeWalker(
          filter: (arg0: AbstractType<any>) => boolean,
        ): YXmlTreeWalker;
        /**
         * Returns the first YXmlElement that matches the query.
         * Similar to DOM's {@link querySelector}.
         *
         * Query support:
         *   - tagname
         * TODO:
         *   - id
         *   - attribute
         *
         * @param {CSS_Selector} query The query on the children.
         * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
         */
        querySelector(
          query: CSS_Selector,
        ): YXmlElement | YXmlText | YXmlHook | null;
        /**
         * Returns all YXmlElements that match the query.
         * Similar to Dom's {@link querySelectorAll}.
         *
         * @todo Does not yet support all queries. Currently only query by tagName.
         *
         * @param {CSS_Selector} query The query on the children
         * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
         */
        querySelectorAll(
          query: CSS_Selector,
        ): Array<YXmlElement | YXmlText | YXmlHook | null>;
        toJSON(): string;
        /**
         * Creates a Dom Element that mirrors this YXmlElement.
         *
         * @param {Document} [_document=document] The document object (you must define
         *                                        this when calling this method in
         *                                        nodejs)
         * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
         *                                             are presented in the DOM
         * @param {any} [binding] You should not set this property. This is
         *                               used if DomBinding wants to create a
         *                               association to the created DOM type.
         * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
         */
        toDOM(
          _document?: Document | undefined,
          hooks?:
            | {
                [x: string]: any;
              }
            | undefined,
          binding?: any,
        ): Node;
        /**
         * Inserts new content at an index.
         *
         * @example
         *  // Insert character 'a' at position 0
         *  xml.insert(0, [new Y.XmlText('text')])
         *
         * @param {number} index The index to insert content at
         * @param {Array<YXmlElement|YXmlText>} content The array of content
         */
        insert(index: number, content: Array<YXmlElement | YXmlText>): void;
        /**
         * Inserts new content at an index.
         *
         * @example
         *  // Insert character 'a' at position 0
         *  xml.insert(0, [new Y.XmlText('text')])
         *
         * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
         * @param {Array<YXmlElement|YXmlText>} content The array of content
         */
        insertAfter(
          ref: null | Struct.Item | YXmlElement | YXmlText,
          content: Array<YXmlElement | YXmlText>,
        ): void;
        /**
         * Deletes elements starting from an index.
         *
         * @param {number} index Index at which to start deleting elements
         * @param {number} [length=1] The number of elements to remove. Defaults to 1.
         */
        delete(index: number, length?: number | undefined): void;
        /**
         * Transforms this YArray to a JavaScript Array.
         *
         * @return {Array<YXmlElement|YXmlText|YXmlHook>}
         */
        toArray(): Array<YXmlElement | YXmlText | YXmlHook>;
        /**
         * Appends content to this YArray.
         *
         * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
         */
        push(content: Array<YXmlElement | YXmlText>): void;
        /**
         * Prepends content to this YArray.
         *
         * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
         */
        unshift(content: Array<YXmlElement | YXmlText>): void;
        /**
         * Returns the i-th element from a YArray.
         *
         * @param {number} index The index of the element to return from the YArray
         * @return {YXmlElement|YXmlText}
         */
        get(index: number): YXmlElement | YXmlText;
        /**
         * Returns a portion of this YXmlFragment into a JavaScript Array selected
         * from start to end (end not included).
         *
         * @param {number} [start]
         * @param {number} [end]
         * @return {Array<YXmlElement|YXmlText>}
         */
        slice(
          start?: number | undefined,
          end?: number | undefined,
        ): Array<YXmlElement | YXmlText>;
        /**
         * Executes a provided function on once on every child element.
         *
         * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
         */
        forEach(
          f: (
            arg0: YXmlElement | YXmlText,
            arg1: number,
            arg2: typeof self,
          ) => void,
        ): void;
      }

      /**
       * Define the elements to which a set of CSS queries apply.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
       */
      type CSS_Selector = string;

      /**
       * An YXmlElement imitates the behavior of a
       * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element
       *
       * * An YXmlElement has attributes (key value pairs)
       * * An YXmlElement has childElements that must inherit from YXmlElement
       *
       * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]
       */
      export class YXmlElement<
        KV extends {
          [key: string]: ValueTypes;
        } = {
          [key: string]: string;
        },
      > extends YXmlFragment {
        constructor(nodeName?: string);
        nodeName: string;
        get nextSibling():
          | YXmlElement<{
              [key: string]: string;
            }>
          | YXmlText
          | null;
        get prevSibling():
          | YXmlElement<{
              [key: string]: string;
            }>
          | YXmlText
          | null;
        /**
         * Makes a copy of this data type that can be included somewhere else.
         *
         * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
         */
        clone(): YXmlElement<KV>;
        /**
         * Removes an attribute from this YXmlElement.
         *
         * @param {string} attributeName The attribute name that is to be removed.
         *
         * @public
         */
        removeAttribute(attributeName: string): void;
        /**
         * Sets or updates an attribute.
         *
         * @template {keyof KV & string} KEY
         *
         * @param {KEY} attributeName The attribute name that is to be set.
         * @param {KV[KEY]} attributeValue The attribute value that is to be set.
         */
        setAttribute<KEY extends keyof KV & string>(
          attributeName: KEY,
          attributeValue: KV[KEY],
        ): void;
        /**
         * Returns an attribute value that belongs to the attribute name.
         *
         * @template {keyof KV & string} KEY
         *
         * @param {KEY} attributeName The attribute name that identifies the
         *                               queried value.
         * @return {KV[KEY]|undefined} The queried attribute value.
         */
        getAttribute<KEY_1 extends keyof KV & string>(
          attributeName: KEY_1,
        ): KV[KEY_1] | undefined;
        /**
         * Returns whether an attribute exists
         *
         * @param {string} attributeName The attribute name to check for existence.
         * @return {boolean} whether the attribute exists.
         */
        hasAttribute(attributeName: string): boolean;
        /**
         * Returns all attribute name/value pairs in a JSON Object.
         *
         * @param {Snapshot} [snapshot]
         * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
         */
        getAttributes(snapshot?: Snapshot.Snapshot | undefined): {
          [Key in Extract<keyof KV, string>]?: KV[Key] | undefined;
        };
      }

      type ValueTypes =
        | Object
        | number
        | null
        | Array<any>
        | string
        | Uint8Array
        | AbstractType<any>;

      /**
       * An Event that describes changes on a YXml Element or Yxml Fragment
       */
      export class YXmlEvent extends Event.YEvent<
        | YXmlElement<{
            [key: string]: string;
          }>
        | YXmlFragment
        | YXmlText
      > {
        /**
         * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
         * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
         *                   child list changed.
         * @param {Transaction} transaction The transaction instance with wich the
         *                                  change was created.
         */
        constructor(
          target: YXmlElement | YXmlText | YXmlFragment,
          subs: Set<string | null>,
          transaction: Transaction,
        );
        /**
         * Set of all changed attributes.
         * @type {Set<string>}
         */
        attributesChanged: Set<string>;
      }

      /**
       * You can manage binding to a custom type with YXmlHook.
       */
      export class YXmlHook extends YMap<any> {
        /**
         * @param {string} hookName nodeName of the Dom Node.
         */
        constructor(hookName: string);
        hookName: string;
        /**
         * Makes a copy of this data type that can be included somewhere else.
         *
         * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
         */
        clone(): YXmlHook;
        /**
         * Creates a Dom Element that mirrors this YXmlElement.
         *
         * @param {Document} [_document=document] The document object (you must define
         *                                        this when calling this method in
         *                                        nodejs)
         * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
         *                                             are presented in the DOM
         * @param {any} [binding] You should not set this property. This is
         *                               used if DomBinding wants to create a
         *                               association to the created DOM type
         * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
         */
        toDOM(
          _document?: Document | undefined,
          hooks?:
            | {
                [x: string]: any;
              }
            | undefined,
          binding?: any,
        ): Element;
      }

      /**
       * Represents text in a Dom Element. In the future this type will also handle
       * simple formatting information like bold and italic.
       */
      export class YXmlText extends YText {
        get nextSibling():
          | YXmlElement<{
              [key: string]: string;
            }>
          | YXmlText
          | null;
        get prevSibling():
          | YXmlElement<{
              [key: string]: string;
            }>
          | YXmlText
          | null;
        /**
         * Makes a copy of this data type that can be included somewhere else.
         *
         * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
         */
        clone(): YXmlText;
        /**
         * Creates a Dom Element that mirrors this YXmlText.
         *
         * @param {Document} [_document=document] The document object (you must define
         *                                        this when calling this method in
         *                                        nodejs)
         * @param {Object<string, any>} [hooks] Optional property to customize how hooks
         *                                             are presented in the DOM
         * @param {any} [binding] You should not set this property. This is
         *                               used if DomBinding wants to create a
         *                               association to the created DOM type.
         * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
         */
        toDOM(
          _document?: Document | undefined,
          hooks?:
            | {
                [x: string]: any;
              }
            | undefined,
          binding?: any,
        ): Text;
        toString(): any;
      }
    }
  }

  module Codec {
    export class DSDecoderV1 {
      constructor(decoder: decoding.Decoder);
      restDecoder: decoding.Decoder;
      resetDsCurVal(): void;
      readDsClock(): number;
      readDsLen(): number;
    }
    export class UpdateDecoderV1 extends DSDecoderV1 {
      readLeftID(): Struct.ID;
      readRightID(): Struct.ID;
      /**
       * Read the next client id.
       * Use this in favor of readID whenever possible to reduce the number of objects created.
       */
      readClient(): number;
      readInfo(): number;
      readString(): string;
      /**
       * @return {boolean} isKey
       */
      readParentInfo(): boolean;
      readTypeRef(): number;
      /**
       * Write len of a struct - well suited for Opt RLE encoder.
       */
      readLen(): number;
      readAny(): any;
      readBuf(): Uint8Array;
      /**
       * Legacy implementation uses JSON parse. We use any-decoding in v2.
       */
      readJSON(): any;
      readKey(): string;
    }
    export class DSDecoderV2 {
      constructor(decoder: decoding.Decoder);
      restDecoder: decoding.Decoder;
      resetDsCurVal(): void;
      readDsClock(): number;
      readDsLen(): number;
    }
    export class UpdateDecoderV2 extends DSDecoderV2 {
      /**
       * List of cached keys. If the keys[id] does not exist, we read a new key
       * from stringEncoder and push it to keys.
       */
      keys: Array<string>;
      keyClockDecoder: decoding.IntDiffOptRleDecoder;
      clientDecoder: decoding.UintOptRleDecoder;
      leftClockDecoder: decoding.IntDiffOptRleDecoder;
      rightClockDecoder: decoding.IntDiffOptRleDecoder;
      infoDecoder: decoding.RleDecoder<number>;
      stringDecoder: decoding.StringDecoder;
      parentInfoDecoder: decoding.RleDecoder<number>;
      typeRefDecoder: decoding.UintOptRleDecoder;
      lenDecoder: decoding.UintOptRleDecoder;
      readLeftID(): Struct.ID;
      readRightID(): Struct.ID;
      /**
       * Read the next client id.
       * Use this in favor of readID whenever possible to reduce the number of objects created.
       */
      readClient(): number;
      readInfo(): number;
      readString(): string;
      readParentInfo(): boolean;
      readTypeRef(): number;
      /**
       * Write len of a struct - well suited for Opt RLE encoder.
       */
      readLen(): number;
      readAny(): any;
      readBuf(): Uint8Array;
      /**
       * This is mainly here for legacy purposes.
       *
       * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
       */
      readJSON(): any;
      readKey(): string;
    }
    export class DSEncoderV1 {
      restEncoder: encoding.Encoder;
      toUint8Array(): Uint8Array;
      resetDsCurVal(): void;
      writeDsClock(clock: number): void;
      writeDsLen(len: number): void;
    }
    export class UpdateEncoderV1 extends DSEncoderV1 {
      writeLeftID(id: Struct.ID): void;
      writeRightID(id: Struct.ID): void;
      /**
       * Use writeClient and writeClock instead of writeID if possible.
       */
      writeClient(client: number): void;
      writeInfo(info: number): void;
      writeString(s: string): void;
      writeParentInfo(isYKey: boolean): void;
      writeTypeRef(info: number): void;
      /**
       * Write len of a struct - well suited for Opt RLE encoder.
       */
      writeLen(len: number): void;
      writeAny(any: any): void;
      writeBuf(buf: Uint8Array): void;
      writeJSON(embed: any): void;
      writeKey(key: string): void;
    }
    export class DSEncoderV2 {
      restEncoder: encoding.Encoder;
      dsCurrVal: number;
      toUint8Array(): Uint8Array;
      resetDsCurVal(): void;
      /**
       * @param {number} clock
       */
      writeDsClock(clock: number): void;
      /**
       * @param {number} len
       */
      writeDsLen(len: number): void;
    }
    export class UpdateEncoderV2 extends DSEncoderV2 {
      /**
       * @type {Map<string,number>}
       */
      keyMap: Map<string, number>;
      /**
       * Refers to the next uniqe key-identifier to me used.
       * See writeKey method for more information.
       *
       * @type {number}
       */
      keyClock: number;
      keyClockEncoder: encoding.IntDiffOptRleEncoder;
      clientEncoder: encoding.UintOptRleEncoder;
      leftClockEncoder: encoding.IntDiffOptRleEncoder;
      rightClockEncoder: encoding.IntDiffOptRleEncoder;
      infoEncoder: encoding.RleEncoder<number>;
      stringEncoder: encoding.StringEncoder;
      parentInfoEncoder: encoding.RleEncoder<number>;
      typeRefEncoder: encoding.UintOptRleEncoder;
      lenEncoder: encoding.UintOptRleEncoder;
      writeLeftID(id: Struct.ID): void;
      writeRightID(id: Struct.ID): void;
      writeClient(client: number): void;
      writeInfo(info: number): void;
      writeString(s: string): void;
      writeParentInfo(isYKey: boolean): void;
      writeTypeRef(info: number): void;
      /**
       * Write len of a struct - well suited for Opt RLE encoder.
       */
      writeLen(len: number): void;
      writeAny(any: any): void;
      writeBuf(buf: Uint8Array): void;
      /**
       * This is mainly here for legacy purposes.
       *
       * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
       */
      writeJSON(embed: any): void;
      /**
       * Property keys are often reused. For example, in y-prosemirror the key `bold` might
       * occur very often. For a 3d application, the key `position` might occur very often.
       *
       * We cache these keys in a Map and refer to them via a unique number.
       */
      writeKey(key: string): void;
    }
  }

  module Update {
    export function readUpdateV2(
      decoder: decoding.Decoder,
      ydoc: Doc,
      transactionOrigin?: any,
      structDecoder?: Codec.UpdateDecoderV1 | Codec.UpdateDecoderV2 | undefined,
    ): void;
    export function readUpdate(
      decoder: decoding.Decoder,
      ydoc: Doc,
      transactionOrigin?: any,
    ): void;
    export function applyUpdateV2(
      ydoc: Doc,
      update: Uint8Array,
      transactionOrigin?: any,
      YDecoder?:
        | typeof Codec.UpdateDecoderV1
        | typeof Codec.UpdateDecoderV2
        | undefined,
    ): void;
    export function applyUpdate(
      ydoc: Doc,
      update: Uint8Array,
      transactionOrigin?: any,
    ): void;
    export function encodeStateAsUpdateV2(
      doc: Doc,
      encodedTargetStateVector?: Uint8Array | undefined,
      encoder?: Codec.UpdateEncoderV2 | Codec.UpdateEncoderV1 | undefined,
    ): Uint8Array;
    export function encodeStateAsUpdate(
      doc: Doc,
      encodedTargetStateVector?: Uint8Array | undefined,
    ): Uint8Array;
    export function decodeStateVector(
      decodedState: Uint8Array,
    ): Map<number, number>;
    export function encodeStateVectorV2(
      doc: Doc | Map<number, number>,
      encoder?: Codec.DSEncoderV1 | Codec.DSEncoderV2 | undefined,
    ): Uint8Array;
    export function encodeStateVector(
      doc: Doc | Map<number, number>,
    ): Uint8Array;

    export function logUpdate(update: Uint8Array): void;
    export function logUpdateV2(
      update: Uint8Array,
      YDecoder?:
        | typeof Codec.UpdateDecoderV1
        | typeof Codec.UpdateDecoderV2
        | undefined,
    ): void;
    export function decodeUpdate(update: Uint8Array): {
      structs: (Struct.GC | Struct.Item | Struct.Skip)[];
      ds: Struct.DeleteSet;
    };
    export function decodeUpdateV2(
      update: Uint8Array,
      YDecoder?:
        | typeof Codec.UpdateDecoderV1
        | typeof Codec.UpdateDecoderV2
        | undefined,
    ): {
      structs: (Struct.GC | Struct.Item | Struct.Skip)[];
      ds: Struct.DeleteSet;
    };

    export function mergeUpdates(updates: Array<Uint8Array>): Uint8Array;
    export function encodeStateVectorFromUpdateV2(
      update: Uint8Array,
      YEncoder?: typeof Codec.DSEncoderV1 | typeof Codec.DSEncoderV2,
      YDecoder?: typeof Codec.UpdateDecoderV1 | typeof Codec.UpdateDecoderV2,
    ): Uint8Array;
    export function encodeStateVectorFromUpdate(update: Uint8Array): Uint8Array;
    export function parseUpdateMetaV2(
      update: Uint8Array,
      YDecoder?: typeof Codec.UpdateDecoderV1 | typeof Codec.UpdateDecoderV2,
    ): {
      from: Map<number, number>;
      to: Map<number, number>;
    };
    export function parseUpdateMeta(update: Uint8Array): {
      from: Map<number, number>;
      to: Map<number, number>;
    };
    export function mergeUpdatesV2(
      updates: Array<Uint8Array>,
      YDecoder?:
        | typeof Codec.UpdateDecoderV1
        | typeof Codec.UpdateDecoderV2
        | undefined,
      YEncoder?:
        | typeof Codec.UpdateEncoderV2
        | typeof Codec.UpdateEncoderV1
        | undefined,
    ): Uint8Array;
    export function diffUpdateV2(
      update: Uint8Array,
      sv: Uint8Array,
      YDecoder?:
        | typeof Codec.UpdateDecoderV1
        | typeof Codec.UpdateDecoderV2
        | undefined,
      YEncoder?:
        | typeof Codec.UpdateEncoderV2
        | typeof Codec.UpdateEncoderV1
        | undefined,
    ): Uint8Array;
    export function diffUpdate(update: Uint8Array, sv: Uint8Array): Uint8Array;
    export function obfuscateUpdate(
      update: Uint8Array,
      opts?: ObfuscatorOptions | undefined,
    ): Uint8Array;
    export function obfuscateUpdateV2(
      update: Uint8Array,
      opts?: ObfuscatorOptions | undefined,
    ): Uint8Array;
    export function convertUpdateFormatV1ToV2(update: Uint8Array): Uint8Array;
    export function convertUpdateFormatV2ToV1(update: Uint8Array): Uint8Array;
    type ObfuscatorOptions = {
      formatting?: boolean | undefined;
      subdocs?: boolean | undefined;
      /**
       * Whether to obfuscate nodeName / hookName
       */
      yxml?: boolean | undefined;
    };
  }
}

declare module RelativePosition {
  /**
   * A relative position is based on the Yjs model and is not affected by document changes.
   * E.g. If you place a relative position before a certain character, it will always point to this character.
   * If you place a relative position at the end of a type, it will always point to the end of the type.
   *
   * A numeric position is often unsuited for user selections, because it does not change when content is inserted
   * before or after.
   *
   * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.
   *
   * One of the properties must be defined.
   *
   * @example
   *   // Current cursor position is at position 10
   *   const relativePosition = createRelativePositionFromIndex(yText, 10)
   *   // modify yText
   *   yText.insert(0, 'abc')
   *   yText.delete(3, 10)
   *   // Compute the cursor position
   *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)
   *   absolutePosition.type === yText // => true
   *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3
   *
   */
  export class RelativePosition {
    constructor(
      type: Y.Struct.ID | null,
      tname: string | null,
      item: Y.Struct.ID | null,
      assoc?: number,
    );
    type: Y.Struct.ID | null;
    tname: string | null;
    item: Y.Struct.ID | null;
    /**
     * A relative position is associated to a specific character. By default
     * assoc >= 0, the relative position is associated to the character
     * after the meant position.
     * I.e. position 1 in 'ab' is associated to character 'b'.
     *
     * If assoc < 0, then the relative position is associated to the caharacter
     * before the meant position.
     */
    assoc: number;
  }
  export function relativePositionToJSON(rpos: RelativePosition): any;
  export function createRelativePositionFromJSON(json: any): RelativePosition;
  export class AbsolutePosition {
    constructor(
      type: Y.Type.AbstractType<any>,
      index: number,
      assoc?: number | undefined,
    );
    type: Y.Type.AbstractType<any>;
    index: number;
    assoc: number;
  }
  export function createAbsolutePosition(
    type: Y.Type.AbstractType<any>,
    index: number,
    assoc?: number | undefined,
  ): AbsolutePosition;
  export function createRelativePosition(
    type: Y.Type.AbstractType<any>,
    item: Y.Struct.ID | null,
    assoc?: number | undefined,
  ): RelativePosition;
  export function createRelativePositionFromTypeIndex(
    type: Y.Type.AbstractType<any>,
    index: number,
    assoc?: number | undefined,
  ): RelativePosition;
  export function encodeRelativePosition(rpos: RelativePosition): Uint8Array;
  export function decodeRelativePosition(
    uint8Array: Uint8Array,
  ): RelativePosition;
  export function createAbsolutePositionFromRelativePosition(
    rpos: RelativePosition,
    doc: Y.Doc,
    followUndoneDeletions?: boolean,
  ): AbsolutePosition | null;
  export function compareRelativePositions(
    a: RelativePosition | null,
    b: RelativePosition | null,
  ): boolean;
}
declare module Snapshot {
  export class Snapshot {
    constructor(ds: Y.Struct.DeleteSet, sv: Map<number, number>);
    ds: Y.Struct.DeleteSet;
    /**
     * State Map
     */
    sv: Map<number, number>;
  }
  export function equalSnapshots(snap1: Snapshot, snap2: Snapshot): boolean;
  export function encodeSnapshotV2(
    snapshot: Snapshot,
    encoder?: Y.Codec.DSEncoderV1 | Y.Codec.DSEncoderV2 | undefined,
  ): Uint8Array;
  export function encodeSnapshot(snapshot: Snapshot): Uint8Array;
  export function decodeSnapshotV2(
    buf: Uint8Array,
    decoder?: Y.Codec.DSDecoderV1 | Y.Codec.DSDecoderV2 | undefined,
  ): Snapshot;
  export function decodeSnapshot(buf: Uint8Array): Snapshot;
  export function createSnapshot(
    ds: Y.Struct.DeleteSet,
    sm: Map<number, number>,
  ): Snapshot;
  export const emptySnapshot: Snapshot;
  export function snapshot(doc: Y.Doc): Snapshot;
  export function createDocFromSnapshot(
    originDoc: Y.Doc,
    snapshot: Snapshot,
    newDoc?: Y.Doc | undefined,
  ): Y.Doc;
  export function snapshotContainsUpdate(
    snapshot: Snapshot,
    update: Uint8Array,
  ): boolean;

  export function typeListToArraySnapshot(
    type: Y.Type.AbstractType<any>,
    snapshot: Snapshot,
  ): Array<any>;
  export function typeMapGetSnapshot(
    parent: Y.Type.AbstractType<any>,
    key: string,
    snapshot: Snapshot,
  ):
    | {
        [x: string]: any;
      }
    | number
    | null
    | Array<any>
    | string
    | Uint8Array
    | Y.Type.AbstractType<any>
    | undefined;
  export function typeMapGetAllSnapshot(
    parent: Y.Type.AbstractType<any>,
    snapshot: Snapshot,
  ): {
    [x: string]:
      | {
          [x: string]: any;
        }
      | number
      | null
      | Array<any>
      | string
      | Uint8Array
      | Y.Type.AbstractType<any>
      | undefined;
  };
}

declare module Utils {
  export class PermanentUserData {
    constructor(doc: Y.Doc, storeType?: Y.Type.YMap<any> | undefined);
    yusers: Y.Type.YMap<any>;
    doc: Y.Doc;
    /**
     * Maps from clientid to userDescription
     */
    clients: Map<number, string>;
    dss: Map<string, Y.Struct.DeleteSet>;
    setUserMapping(
      doc: Y.Doc,
      clientid: number,
      userDescription: string,
      conf?: {
        filter?:
          | ((arg0: Y.Transaction, arg1: Y.Struct.DeleteSet) => boolean)
          | undefined;
      },
    ): void;
    getUserByClientId(clientid: number): any;
    getUserByDeletedId(id: Y.Struct.ID): string | null;
  }

  export class StackItem {
    constructor(deletions: Y.Struct.DeleteSet, insertions: Y.Struct.DeleteSet);
    insertions: Y.Struct.DeleteSet;
    deletions: Y.Struct.DeleteSet;
    /**
     * Use this to save and restore metadata like selection range
     */
    meta: Map<any, any>;
  }
  /**
   * Fires 'stack-item-added' event when a stack item was added to either the undo- or
   * the redo-stack. You may store additional stack information via the
   * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).
   * Fires 'stack-item-popped' event when a stack item was popped from either the
   * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.
   */
  export class UndoManager extends ObservableV2<{
    "stack-item-added": (arg0: StackItemEvent, arg1: UndoManager) => void;
    "stack-item-popped": (arg0: StackItemEvent, arg1: UndoManager) => void;
    "stack-cleared": (arg0: {
      undoStackCleared: boolean;
      redoStackCleared: boolean;
    }) => void;
    "stack-item-updated": (arg0: StackItemEvent, arg1: UndoManager) => void;
  }> {
    /**
     * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
     * @param {UndoManagerOptions} options
     */
    constructor(
      typeScope: Y.Type.AbstractType<any> | Array<Y.Type.AbstractType<any>>,
      options?: UndoManagerOptions,
    );
    /**
     * @type {Array<AbstractType<any>>}
     */
    scope: Array<Y.Type.AbstractType<any>>;
    doc: Y.Doc;
    deleteFilter: (arg0: Y.Struct.Item) => boolean;
    trackedOrigins: Set<any>;
    captureTransaction: (arg0: Y.Transaction) => boolean;
    undoStack: Array<StackItem>;
    redoStack: Array<StackItem>;
    /**
     * Whether the client is currently undoing (calling UndoManager.undo)
     */
    undoing: boolean;
    redoing: boolean;
    /**
     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing
     */
    currStackItem: StackItem | null;
    lastChange: number;
    ignoreRemoteMapChanges: boolean;
    captureTimeout: number;
    afterTransactionHandler: (transaction: Y.Transaction) => void;
    addToScope(
      ytypes: Array<Y.Type.AbstractType<any>> | Y.Type.AbstractType<any>,
    ): void;
    addTrackedOrigin(origin: any): void;
    removeTrackedOrigin(origin: any): void;
    clear(clearUndoStack?: boolean, clearRedoStack?: boolean): void;
    /**
     * UndoManager merges Undo-StackItem if they are created within time-gap
     * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
     * StackItem won't be merged.
     *
     *
     * @example
     *     // without stopCapturing
     *     ytext.insert(0, 'a')
     *     ytext.insert(1, 'b')
     *     um.undo()
     *     ytext.toString() // => '' (note that 'ab' was removed)
     *     // with stopCapturing
     *     ytext.insert(0, 'a')
     *     um.stopCapturing()
     *     ytext.insert(0, 'b')
     *     um.undo()
     *     ytext.toString() // => 'a' (note that only 'b' was removed)
     *
     */
    stopCapturing(): void;
    /**
     * Undo last changes on type.
     */
    undo(): StackItem | null;
    /**
     * Redo last undo operation.
     */
    redo(): StackItem | null;
    /**
     * Are undo steps available?
     */
    canUndo(): boolean;
    /**
     * Are redo steps available?
     */
    canRedo(): boolean;
  }
  type UndoManagerOptions = {
    captureTimeout?: number | undefined;
    /**
     * Do not capture changes of a Transaction if result false.
     */
    captureTransaction?: ((arg0: Y.Transaction) => boolean) | undefined;
    /**
     * Sometimes
     * it is necessary to filter what an Undo/Redo operation can delete. If this
     * filter returns false, the type/item won't be deleted even it is in the
     * undo/redo scope.
     */
    deleteFilter?: ((arg0: Y.Struct.Item) => boolean) | undefined;
    trackedOrigins?: Set<any> | undefined;
    /**
     * Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).
     */
    ignoreRemoteMapChanges?: boolean | undefined;
    /**
     * The document that this UndoManager operates on. Only needed if typeScope is empty.
     */
    doc?: Y.Doc | undefined;
  };
  type StackItemEvent = {
    stackItem: StackItem;
    origin: any;
    type: "undo" | "redo";
    changedParentTypes: Map<
      Y.Type.AbstractType<Y.Type.Event.YEvent<any>>,
      Array<Y.Type.Event.YEvent<any>>
    >;
  };
}
